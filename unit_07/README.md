# jsq-danco

Коллекции
=========
childNodes, firstChild, lastChild
=================================

Псевдо-массив childNodes хранит все дочерние элементы, включая текстовые.

дочерние элементы document.body:
-------------------------------
```
<!DOCTYPE HTML>
<html>

<body>
  <div>Начало</div>

  <ul>
    <li>Информация</li>
  </ul>

  <div>Конец</div>

  <script>
    for (var i = 0; i < document.body.childNodes.length; i++) {
      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT
    }
  </script>
  ...
</body>

</html>
```

Свойства firstChild и lastChild обеспечивают быстрый доступ к первому и последнему элементу.

При наличии дочерних узлов всегда верно:
```
elem.childNodes[0] === elem.firstChild
elem.childNodes[elem.childNodes.length - 1] === elem.lastChild
```

DOM-коллекции, такие как childNodes не являются JavaScript-массивами.

В них нет методов массивов, таких как forEach, map, push, pop и других.

Именно поэтому childNodes и называют «коллекция» или «псевдомассив».

Можно для перебора коллекции использовать обычный цикл

```
    for(var i=0; i<elems.length; i++)
```

Именно воспользоваться методами массива

Применить метод массива через call/apply:
-----------------------------------------

```
var elems = document.documentElement.childNodes;

[].forEach.call(elems, function(elem) {
  alert( elem ); // HEAD, текст, BODY
});
```
При помощи Array.prototype.slice сделать из коллекции массив.
-------------------------------------------------------------

Обычно вызов arr.slice(a, b) делает новый массив и копирует туда элементы arr с индексами от a до b-1 включительно. Если же вызвать его без аргументов arr.slice(), то он делает новый массив и копирует туда все элементы arr.

Это работает и для коллекции:
```
var elems = document.documentElement.childNodes;
elems = Array.prototype.slice.call(elems); // теперь elems - массив

elems.forEach(function(elem) {
  alert( elem.tagName ); // HEAD, текст, BODY
});
```
Нельзя перебирать коллекцию через for..in
-----------------------------------------

Но в примере ниже alert сработает не три, а целых 5 раз!
```
var elems = document.documentElement.childNodes;

for (var key in elems) {
  alert( key ); // 0, 1, 2, length, item
}
```
Цикл for..in выведет не только ожидаемые индексы 0, 1, 2, по которым лежат узлы в коллекции, но и свойство length (в коллекции оно enumerable), а также функцию item(n) — она никогда не используется, возвращает n-й элемент коллекции, проще обратиться по индексу [n].

Поэтому желательно использовать
```
for(var i=0; i<elems.length; i++)
```
Соседи и родитель
------------------
Доступ к элементам слева и справа данного можно получить по ссылкам previousSibling / nextSibling.

Родитель доступен через parentNode.
-----------------------------------

Навигация только по элементам
------------------------------
В childNodes сосуществуют и текстовые узлы и узлы-элементы и узлы-комментарии, если есть.

Но для большинства задач текстовые узлы нам не интересны.

дополнительный набор ссылок, которые их не учитывают:
-----------------------------------------------------

- children — только дочерние узлы-элементы, то есть соответствующие тегам.
- firstElementChild, lastElementChild — первый и последний дети-элементы.
- previousElementSibling, nextElementSibling — соседи-элементы.
- parentElement — родитель-элемент.

Свойство elem.parentNode возвращает родитель элемента.
------------------------------------------------------
Оно всегда равно parentElement, кроме одного исключения:
```
alert( document.documentElement.parentNode ); // document
alert( document.documentElement.parentElement ); // null
```
Пример:
```
<!DOCTYPE HTML>
<html>

<body>
  <div>Начало</div>

  <ul>
    <li>Информация</li>
  </ul>

  <div>Конец</div>

  <script>
    for (var i = 0; i < document.body.children.length; i++) {
      alert( document.body.children[i] ); // DIV, UL, DIV, SCRIPT
    }
  </script>
  ...
</body>

</html>
```
Всегда верны равенства:
```
elem.firstElementChild === elem.children[0]
elem.lastElementChild === elem.children[elem.children.length - 1]
```

Размеры и прокрутка элементов
==============================
Для того, чтобы показывать элементы на произвольных местах страницы, необходимо во-первых, знать CSS-позиционирование, а во-вторых — уметь работать с «геометрией элементов» из JavaScript.

Метрики
=======
У элементов существует ряд свойств, содержащих их внешние и внутренние размеры - метрики.

Метрики, в отличие от свойств CSS, содержат числа, всегда в пикселях и без единиц измерения на конце.

offsetParent, offsetLeft/Top
----------------------------
В offsetParent находится ссылка на родительский элемент в смысле отображения на странице.

Когда браузер рисует страницу, то он высчитывает дерево расположения элементов, иначе говоря «дерево геометрии» или «дерево рендеринга», которое содержит всю информацию о размерах.

При этом одни элементы естественным образом рисуются внутри других. Но если у элемента стоит position:absolute, то его расположение вычисляется уже не относительно непосредственного родителя parentNode, а относительно ближайшего позиционированного элемента (т.е. свойство position которого не равно static), или BODY, если такой отсутствует.

Получается, что элемент имеет в дополнение к обычному родителю в DOM — ещё одного «родителя по позиционированию», то есть относительно которого он рисуется. Этот элемент и будет в свойстве offsetParent.

Свойства offsetLeft/Top задают смещение относительно offsetParent.
------------------------------------------------------------------
В примере ниже внутренний div имеет DOM-родителя form, но offsetParent у него main, и сдвиги относительно его верхнего-левого угла будут в offsetLeft/Top:
```
<main style="position: relative">
  <form>
    <div id="example" style="position: absolute; left: 180px; top: 180px">...</div>
  </form>
</main>
```

offsetWidth/Height
-------------------

Эти два свойства содержат «внешнюю» ширину/высоту элемента, то есть его полный размер, включая рамки border.

Метрики для невидимых элементов равны нулю.
Координаты и размеры в JavaScript устанавливаются только для видимых элементов.

Для элементов с display:none или находящихся вне документа дерево рендеринга не строится. Для них метрики равны нулю. offsetParent для таких элементов тоже null.

Это дает нам замечательный способ для проверки, виден ли элемент:
```
function isHidden(elem) {
  return !elem.offsetWidth && !elem.offsetHeight;
}
```

Работает, даже если родителю элемента установлено свойство display:none.
Работает для всех элементов, кроме TR, с которым возникают некоторые проблемы в разных браузерах.
Считает элемент видимым, даже если позиционирован за пределами экрана или имеет свойство visibility:hidden.
«Схлопнутый» элемент, например пустой div без высоты и ширины, будет считаться невидимым.
clientTop/Left

свойства-метрики clientTop и clientLeft.
---------------------------------------

— отступ внутренней части элемента от внешней.


clientWidth/Height
-------------------
Эти свойства — размер элемента внутри рамок border.

Они включают в себя ширину содержимого width вместе с полями padding, но без прокрутки.

Если padding нет, то clientWidth/Height в точности равны размеру области содержимого, внутри рамок и полосы прокрутки.

scrollWidth/Height
------------------
Эти свойства — аналоги clientWidth/clientHeight, но с учетом прокрутки.

Свойства clientWidth/clientHeight относятся только к видимой области элемента, а scrollWidth/scrollHeight добавляют к ней прокрученную (которую не видно) по горизонтали/вертикали.

Эти свойства можно использовать, чтобы «распахнуть» элемент на всю ширину/высоту, таким кодом:
```
element.style.height = element.scrollHeight + 'px';
```

scrollLeft/scrollTop
---------------------
Свойства scrollLeft/scrollTop — ширина/высота невидимой, прокрученной в данный момент, части элемента слева и сверху.

В отличие от большинства свойств, которые доступны только для чтения, значения scrollLeft/scrollTop можно изменить, и браузер выполнит прокрутку элемента.


У элементов есть следующие метрики:
-----------------------------------
- offsetParent — «родитель по дереву рендеринга» — ближайшая ячейка таблицы, body для статического позиционирования или ближайший позиционированный элемент для других типов позиционирования.
- offsetLeft/offsetTop — позиция в пикселях левого верхнего угла блока, относительно его offsetParent.
- offsetWidth/offsetHeight — «внешняя» ширина/высота блока, включая рамки.
- clientLeft/clientTop — отступ области содержимого от левого-верхнего угла элемента. Если операционная система располагает вертикальную прокрутку справа, то равны ширинам левой/верхней рамки, если же слева (ОС на иврите, арабском), то clientLeft включает в себя прокрутку.
- clientWidth/clientHeight — ширина/высота содержимого вместе с полями padding, но без полосы прокрутки.
- scrollWidth/scrollHeight — ширина/высота содержимого, включая прокручиваемую область. Включает в себя padding и не включает полосы прокрутки.
- scrollLeft/scrollTop — ширина/высота прокрученной части документа, считается от верхнего левого угла.
Все свойства, доступны только для чтения, кроме scrollLeft/scrollTop. Изменение этих свойств заставляет браузер прокручивать элемент.
