# danco-js UNIT 02

# функции

- Определение функции – обычное определение переменной, где значение, которое получает переменная, является функцией.

```
var square = function(x) {
  return x * x;
};

console.log(square(12));
// → 144

```

Функция создаётся выражением, начинающимся с ключевого слова function. У функций есть набор параметров (в данном случае, только x), и тело, содержащее инструкции, которые необходимо выполнить при вызове функции. Тело функции всегда заключают в фигурные скобки, даже если оно состоит из одной инструкции. 
У функции может быть несколько параметров, или вообще их не быть. 

```
var makeNoise = function() {
  console.log("Хрясь!");
};

makeNoise();
// → Хрясь!

var power = function(base, exponent) {
  var result = 1;
  for (var count = 0; count < exponent; count++)
    result *= base;
  return result;
};

console.log(power(2, 10));
// → 1024
```

# Для возврата значения используется директива return.

Инструкция return определяет значение, возвращаемое функцией. Она может находиться в любом месте функции. Как только до нее доходит управление — функция завершается и значение передается обратно.

# Вызовов return может быть и несколько, например:

```
function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    return confirm('Родители разрешили?');
  }
}

var age = prompt('Ваш возраст?');

if (checkAge(age)) {
  alert( 'Доступ разрешен' );
} else {
  alert( 'В доступе отказано' );
}
```
# Директива return может также использоваться без значения, чтобы прекратить выполнение и выйти из функции.

```

function showMovie(age) {
  if (!checkAge(age)) {
    return;
  }

  alert( "Фильм не для всех" ); // (*)
  // ...
}
```

# Значение функции без return и с пустым return

В случае, когда функция не вернула значение или return был без аргументов, считается что она вернула undefined:
```
function doNothing() { /* пусто */ }

alert( doNothing() ); // undefined
```

# return без аргумента:
```
function doNothing() {
  return;
}

alert( doNothing() === undefined ); // true

```
Function Declaration
--------------------
```
// Function Declaration
function sum(a, b) {
  return a + b;
}

// Function Expression
var sum = function(a, b) {
  return a + b;
}
```
Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.

Функциональные выражения
-------------------------
В JavaScript функция является значением, таким же как строка или число.

Как и любое значение, объявленную функцию можно вывести, вот так:
```
function sayHi() {
  alert( "Привет" );
}

alert( sayHi ); // выведет код функции
```
Функцию можно скопировать в другую переменную:
```
function sayHi() {   // (1)
  alert( "Привет" );
}

var func = sayHi;    // (2)
func(); // Привет    // (3)

sayHi = null;
sayHi();             // ошибка (4)
```
Обычные значения, такие как числа или строки, представляют собой данные. А функцию можно воспринимать как действие.

Объявление Function Expression
--------------------------------
«Function Expression» (функциональное выражение) и выглядит так:
```
var f = function(параметры) {
  // тело функции
};
var sayHi = function(person) {
  alert( "Привет, " + person );
};

sayHi('Вася');
```
Условное объявление функции
----------------------------
В некоторых случаях «дополнительное удобство» Function Declaration может сослужить плохую службу.

Например, попробуем, в зависимости от условия, объявить функцию sayHi по-разному:
var age = +prompt("Сколько вам лет?", 20);
```
if (age >= 18) {
  function sayHi() {
    alert( 'Прошу вас!' );
  }
} else {
  function sayHi() {
    alert( 'До 18 нельзя' );
  }
}

sayHi();
```
Function Declaration обрабатываются перед запуском кода. Интерпретатор сканирует код и создает из таких объявлений функции. При этом второе объявление перезапишет первое.
Дальше, во время выполнения, объявления Function Declaration игнорируются (они уже были обработаны). Это как если бы код был таким:
```
function sayHi() {
  alert( 'Прошу вас!' );
}

function sayHi() {
  alert( 'До 18 нельзя' );
}

var age = 20;

if (age >= 18) {
  /* объявление было обработано ранее */
} else {
  /* объявление было обработано ранее */
}

sayHi(); // "До 18 нельзя", сработает всегда вторая функция
```
Вывод: для условного объявления функций Function Declaration не годится.

А что, если использовать Function Expression?
```
var age = prompt('Сколько вам лет?');

var sayHi;

if (age >= 18) {
  sayHi = function() {
    alert( 'Прошу Вас!' );
  }
} else {
  sayHi = function() {
    alert( 'До 18 нельзя' );
  }
}

sayHi();
var age = prompt('Сколько вам лет?');

var sayHi = (age >= 18) ?
  function() { alert('Прошу Вас!');  } :
  function() { alert('До 18 нельзя'); };

sayHi();
```
Анонимные функции
-----------------
Взглянем ещё на один пример.

Функция ask(question, yes, no) предназначена для выбора действия в зависимости от результата f.

Она выводит вопрос на подтверждение question и, в зависимости от согласия пользователя, вызывает yes или no:
```
function ask(question, yes, no) {
    if (confirm(question)) yes()
    else no();
  }

function showOk() {
  alert( "Вы согласились." );
}

function showCancel() {
  alert( "Вы отменили выполнение." );
}

// использование
ask("Вы согласны?", showOk, showCancel);
```

при работе со страницей такие функции как раз очень востребованы, только вот спрашивают они не простым confirm, а выводят более красивое окно с вопросом и могут интеллектуально обработать ввод посетителя. Но это всё в своё время.

Здесь обратим внимание на то, что то же самое можно написать более коротко:
```
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);
```
Функциональное выражение, которое не записывается в переменную, называют анонимной функцией.

new Function
---------------
создавать функцию на лету из строки:
```
var sum = new Function('a,b', ' return a+b; ');

var result = sum(1, 2);
alert( result ); // 3
```
То есть, функция создаётся вызовом new Function(params, code):

- params
Параметры функции через запятую в виде строки.
- code
Код функции в виде строки.
Таким образом можно конструировать функцию, код которой неизвестен на момент написания программы, но строка с ним генерируется или подгружается динамически во время её выполнения.

Параметры и область видимости
-----------------------------
Параметры функции – такие же переменные, но их начальные значения задаются при вызове функции, а не в её коде. 
Важное свойство функций в том, что переменные, созданные внутри функции (включая параметры), локальны внутри этой функции. 
Эта локальность переменных применяется только к параметрам и созданным внутри функций переменным. Переменные, заданные снаружи какой бы то ни было функции, называются глобальными, поскольку они видны на протяжении всей программы. Получить доступ к таким переменным можно и внутри функции, если только вы не объявили локальную переменную с тем же именем. 
Следующий код иллюстрирует это. Он определяет и вызывает две функции, которые присваивают значение переменной x. Первая объявляет её как локальную, тем самым меняя только локальную переменную. Вторая не объявляет, поэтому работа с x внутри функции относится к глобальной переменной x, заданной в начале примера.
```
var x = "outside";

var f1 = function() {
  var x = "inside f1";
};
f1();
console.log(x);
// → outside

var f2 = function() {
  x = "inside f2";
};
f2();
console.log(x);
// → inside f2
```
Вложенные области видимости
---------------------------
JavaScript различает не только глобальные и локальные переменные. Функции можно задавать внутри функций, что приводит к нескольким уровням локальности.
```
var landscape = function() {
  var result = "";
  var flat = function(size) {
    for (var count = 0; count < size; count++)
      result += "_";
  };
  var mountain = function(size) {
    result += "/";
    for (var count = 0; count < size; count++)
      result += "'";
    result += "\\";
  };

  flat(3);
  mountain(4);
  flat(6);
  mountain(1);
  flat(1);
  return result;
};

console.log(landscape());
// → ___/''''\______/'\_
```

Необязательные аргументы
-------------------------
```
alert("Здрасьте", "Добрый вечер", "Всем привет!");
```
Официально функция принимает один аргумент. Однако, при таком вызове она не жалуется. Она игнорирует остальные аргументы и показывает «Здрасьте». 
JavaScript очень лоялен по поводу количества аргументов, передаваемых функции. Если вы передадите слишком много, лишние будут проигнорированы. Слишком мало – отсутствующим будет назначено значение undefined. 

Плюс в том, что вы можете создавать функции, принимающие необязательные аргументы. К примеру, в следующей версии функции power её можно вызывать как с двумя, так и с одним аргументом,- в последнем случае экспонента будет равна двум, и функция работает как квадрат.
```
function power(base, exponent) {
  if (exponent == undefined)
    exponent = 2;
  var result = 1;
  for (var count = 0; count < exponent; count++)
    result *= base;
  return result;
}

console.log(power(4));
// → 16
console.log(power(4, 3));
// → 64
```
К примеру, console.log выводит все переданные ему аргументы:
```
console.log("R", 2, "D", 2);
// → R 2 D 2
```
Замыкания
---------
Возможность использовать вызовы функций как переменные вкупе с тем фактом, что локальные переменные каждый раз при вызове функции создаются заново, приводит нас к интересному вопросу. Что происходит с локальными переменными, когда функция перестаёт работать? 
Следующий пример иллюстрирует этот вопрос. В нём объявляется функция wrapValue, которая создаёт локальную переменную. Затем она возвращает функцию, которая читает эту локальную переменную и возвращает её значение.
```
function wrapValue(n) {
  var localVariable = n;
  return function() { return localVariable; };
}

var wrap1 = wrapValue(1);
var wrap2 = wrapValue(2);
console.log(wrap1());
// → 1
console.log(wrap2());
// → 2
```
Это допустимо и работает так, как должно – доступ к переменной остаётся. Более того, в одно и то же время могут существовать несколько экземпляров одной и той же переменной, что ещё раз подтверждает тот факт, что с каждым вызовом функции локальные переменные пересоздаются. 
Эта возможность работать со ссылкой на какой-то экземпляр локальной переменной называется замыканием. Функция, замыкающая локальные переменные, называется замыкающей. Она не только освобождает вас от забот, связанных с временем жизни переменных, но и позволяет творчески использовать функции.
```
function multiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

var twice = multiplier(2);
console.log(twice(5));
// → 10
```

Рекурсия
--------
Функция может вызывать сама себя, если она заботится о том, чтобы не переполнить стек. Такая функция называется рекурсивной. Вот пример альтернативной реализации возведения в степень:
```
function power(base, exponent) {
  if (exponent == 0)
    return 1;
  else
    return base * power(base, exponent - 1);
}

console.log(power(2, 3));
// → 8
```

Сверхкороткие имена функций
---------------------------
Имена функций, которые используются очень часто, иногда делают сверхкороткими. Например, во фреймворке jQuery есть функция $, во фреймворке Prototype — функция $$, а в библиотеке LoDash очень активно используется функция с названием из одного символа подчеркивания _.

Наборы данных
-------------
массив (array):
```
var listOfNumbers = [2, 3, 5, 7, 11];
console.log(listOfNumbers[1]);
// → 3
console.log(listOfNumbers[1 - 1]);
// → 2
```

Номер первого элемента – ноль. Поэтому первый элемент можно получить так: listOfNumbers[0].

Свойства
--------
Почти у всех переменных в JavaScript есть свойства. Исключения — null и undefined. Если вы попробуете получить доступ к несуществующим свойствам этих не-величин, получите ошибку:
```
null.length;
// → TypeError: Cannot read property 'length' of null
```
методы и свойства
=================
Все значения в JavaScript, за исключением null и undefined, содержат набор вспомогательных функций и значений, доступных «через точку».

Такие функции называют «методами», а значения — «свойствами». 

Свойство str.length
-------------------

У строки есть свойство length, содержащее длину:
```
alert( "Привет, мир!".length ); // 12
```
Можно и записать строку в переменную, а потом запросить её свойство:
```
var str = "Привет, мир!";
alert( str.length ); // 12
```
Метод str.toUpperCase()
-----------------------
Также у строк есть метод toUpperCase(), который возвращает строку в верхнем регистре:
```
var hello = "Привет, мир!";

alert( hello.toUpperCase() ); // "ПРИВЕТ, МИР!"
```
Вызов метода — через круглые скобки
-----------------------------------
Обратите внимание, для вызова метода обязательно нужны круглые скобки.

Пример, результат обращения к toUpperCase без скобок:
------------------------------------------------------
```
var hello = "Привет";

alert( hello.toUpperCase ); // function...
```
Метод — это встроенная функция, которую нужно вызвать для получения значения. При обращении без скобок мы получим саму эту функцию. Как правило браузер выведет её как-то так: "function toUpperCase() { ... }".

А чтобы получить результат — нужно произвести её вызов, добавив скобки:
```
var hello = "Привет";

alert( hello.toUpperCase() ); // ПРИВЕТ
```

Метод num.toFixed(n)
--------------------
Есть методы и у чисел, например num.toFixed(n). Он округляет число num до n знаков после запятой, при необходимости добивает нулями до данной длины и возвращает в виде строки (удобно для форматированного вывода):
```
var n = 12.345;

alert( n.toFixed(2) ); // "12.35"
alert( n.toFixed(0) ); // "12"
alert( n.toFixed(5) ); // "12.34500"
```

Обращение к методам чисел
-------------------------
К методу числа можно обратиться и напрямую:
```
alert( 12.34.toFixed(1) ); // 12.3
```
…Но если число целое, то будет проблема:
```
alert(12.toFixed(1)); // ошибка!
```
Ошибка произойдёт потому, что JavaScript ожидает десятичную дробь после точки.

Это — особенность синтаксиса JavaScript.
```
alert( 12..toFixed(1) ); // 12.0
```

Числа
======
Все числа в JavaScript, как целые так и дробные, имеют тип Number и хранятся в 64-битном формате IEEE-754, также известном как «double precision».

Способы записи
---------------
В JavaScript можно записывать числа не только в десятичной, но и в шестнадцатеричной (начинается с 0x) системе счисления:
```
alert( 0xFF ); // 255 в шестнадцатиричной системе
```
Также доступна запись в «научном формате» (ещё говорят «запись с плавающей точкой»), который выглядит как числоEкол-во нулей.

Например, 1e3 — это 1 с 3 нулями, то есть 1000.
```
// еще пример научной формы: 3 с 5 нулями
alert( 3e5 ); // 300000
```
Если количество нулей отрицательно, то число сдвигается вправо за десятичную точку, так что получается десятичная дробь:
```
// здесь 3 сдвинуто 5 раз вправо, за десятичную точку.
alert( 3e-5 ); // 0.00003  <-- 5 нулей, включая начальный ноль
```
Деление на ноль, Infinity
-------------------------
Что должно происходить при попытке деления на ноль?

Как правило, ошибка в программе… Во всяком случае, в большинстве языков программирования это именно так.

Но создатель JavaScript решил пойти математически правильным путем. Ведь чем меньше делитель, тем больше результат. При делении на очень-очень маленькое число должно получиться очень большое. В математическом анализе это описывается через пределы, и если подразумевать предел, то в качестве результата деления на 0 мы получаем «бесконечность», которая обозначается символом ∞ или, в JavaScript: "Infinity".
```
alert( 1 / 0 ); // Infinity
alert( 12345 / 0 ); // Infinity
```
Infinity — особенное численное значение, которое ведет себя в точности как математическая бесконечность ∞.

Infinity больше любого числа.
-----------------------------
Добавление к бесконечности не меняет её.
```
alert( Infinity > 1234567890 ); // true
alert( Infinity + 5 == Infinity ); // true
```
Бесконечность можно присвоить и в явном виде: var x = Infinity.

Бывает и минус бесконечность -Infinity:
----------------------------------------
```
alert( -1 / 0 ); // -Infinity
```
Бесконечность можно получить также, если сделать ну очень большое число, для которого количество разрядов в двоичном представлении не помещается в соответствующую часть стандартного 64-битного формата, например:
```
alert( 1e500 ); // Infinity
```
NaN
----
Если математическая операция не может быть совершена, то возвращается специальное значение NaN (Not-A-Number).

Например, деление 0/0 в математическом смысле неопределено, поэтому его результат NaN:
```
alert( 0 / 0 ); // NaN
```
Значение NaN используется для обозначения математической ошибки и обладает следующими свойствами:

Значение NaN — единственное, в своем роде, которое не равно ничему, включая себя.
Следующий код ничего не выведет:
```
if (NaN == NaN) alert( "==" ); // Ни один вызов
if (NaN === NaN) alert( "===" ); // не сработает
```
Значение NaN можно проверить специальной функцией isNaN(n), которая преобразует аргумент к числу и возвращает true, если получилось NaN, и false — для любого другого значения.
```
var n = 0 / 0;

alert( isNaN(n) ); // true
alert( isNaN("12") ); // false, строка преобразовалась к обычному числу 12
```
способ проверки на NaN
-----------------------
можно проверить значение на равенство самому себе, если не равно — то NaN:
```
var n = 0 / 0;

if (n !== n) alert( 'n = NaN!' );
```
Это работает, но для наглядности лучше использовать isNaN(n).

Любая операция с NaN возвращает NaN.
------------------------------------
```
alert( NaN + 1 ); // NaN
```
Если аргумент isNaN — не число, то он автоматически преобразуется к числу.

Математические операции в JS безопасны
---------------------------------------
Никакие математические операции в JavaScript не могут привести к ошибке или «обрушить» программу.
В худшем случае, результат будет NaN.

isFinite(n)
-----------
Итак, в JavaScript есть обычные числа и три специальных числовых значения: NaN, Infinity и -Infinity.

Тот факт, что они, хоть и особые, но — числа, демонстрируется работой оператора +:
```
var value = prompt("Введите Infinity", 'Infinity');

var number = +value;

alert( number ); // Infinity, плюс преобразовал строку "Infinity" к такому "числу"
```
Обычно если мы хотим от посетителя получить число, то Infinity или NaN нам не подходят. Для того, чтобы отличить «обычные» числа от таких специальных значений, существует функция isFinite.

Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity:
```
alert( isFinite(1) ); // true
alert( isFinite(Infinity) ); // false
alert( isFinite(NaN) ); // false
```
Преобразование к числу
----------------------
Большинство арифметических операций и математических функций преобразуют значение в число автоматически.

Для того, чтобы сделать это явно, обычно перед значением ставят унарный плюс '+':
```
var s = "12.34";
alert( +s ); // 12.34
```
При этом, если строка не является в точности числом, то результат будет NaN:
```
alert( +"12test" ); // NaN
```
Единственное исключение — пробельные символы в начале и в конце строки, которые игнорируются:
```
alert( +"  -12" ); // -12
alert( +" \n34  \n" ); // 34, перевод строки \n является пробельным символом
alert( +"" ); // 0, пустая строка становится нулем
alert( +"1 2" ); // NaN, пробел посередине числа - ошибка
```
Аналогичным образом происходит преобразование и в других математических операторах и функциях:
```
alert( '12.34' / "-2" ); // -6.17
```
Мягкое преобразование: parseInt и parseFloat
--------------------------------------------
В мире HTML/CSS многие значения не являются в точности числами. Например, метрики CSS: 10pt или -12px.

Оператор '+' для таких значений возвратит NaN:
```
alert(+"12px") // NaN
```
Для удобного чтения таких значений существует функция parseInt:
```
alert( parseInt('12px') ); // 12
```
Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.

При возникновении ошибки возвращается число, которое получилось. Функция parseInt читает из строки целое число, а parseFloat — дробное.
```
alert( parseInt('12px') ) // 12, ошибка на символе 'p'
alert( parseFloat('12.3.4') ) // 12.3, ошибка на второй точке
```
Конечно, существуют ситуации, когда parseInt/parseFloat возвращают NaN. Это происходит при ошибке на первом же символе:
```
alert( parseInt('a123') ); // NaN
```
Функция parseInt также позволяет указать систему счисления, то есть считывать числа, заданные в шестнадцатиричной и других системах счисления:
```
alert( parseInt('FF', 16) ); // 255
```
Проверка на число
------------------
Для проверки строки на число можно использовать функцию isNaN(str).

Она преобразует строку в число аналогично +, а затем вернёт true, если это NaN, т.е. если преобразование не удалось:
```
var x = prompt("Введите значение", "-11.5");

if (isNaN(x)) {
  alert( "Строка преобразовалась в NaN. Не число" );
} else {
  alert( "Число" );
}
```
Однако, у такой проверки есть две особенности:

Пустая строка и строка из пробельных символов преобразуются к 0, поэтому считаются числами.
Если применить такую проверку не к строке, то могут быть сюрпризы, в частности isNaN посчитает числами значения false, true, null, так как они хотя и не числа, но преобразуются к ним.
```
alert( isNaN(null) ); //  false - не NaN, т.е. "число"
alert( isNaN("\n  \n") ); //  false - не NaN, т.е. "число"
```
Если такое поведение допустимо, то isNaN — приемлемый вариант.

Если же нужна действительно точная проверка на число, которая не считает числом строку из пробелов, логические и специальные значения, а также отсекает Infinity — используйте следующую функцию isNumeric:
```
function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
```

- Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не Infinity/-Infinity/NaN.
Таким образом, правая часть отсеет заведомо не-числа, но оставит такие значения как true/false/null и пустую строку '', т.к. они корректно преобразуются в числа.

- Для их проверки нужна левая часть. Вызов parseFloat(true/false/null/'') вернёт NaN для этих значений.
Так устроена функция parseFloat: она преобразует аргумент к строке, т.е. true/false/null становятся "true"/"false"/"null", а затем считывает из неё число, при этом пустая строка даёт NaN.

В результате отсеивается всё, кроме строк-чисел и обычных чисел.

toString(система счисления)
----------------------------
числа можно записывать не только в 10-чной, но и в 16-ричной системе. Но бывает и противоположная задача: получить 16-ричное представление числа. Для этого используется метод toString(основание системы), например:
```
var n = 255;

alert( n.toString(16) ); // ff
```
В частности, это используют для работы с цветовыми значениями в браузере, вида #AABBCC.

Основание может быть любым от 2 до 36.

Основание 2 бывает полезно для отладки побитовых операций:
----------------------------------------------------------
```
var n = 4;
alert( n.toString(2) ); // 100
```
Основание 36 (по количеству букв в английском алфавите — 26, вместе с цифрами, которых 10) 
------------------------------------------------------------------------------------------
используется для того, чтобы «кодировать» число в виде буквенно-цифровой строки. В этой системе счисления сначала используются цифры, а затем буквы от a до z:
```
var n = 1234567890;
alert( n.toString(36) ); // kf12oi
```
При помощи такого кодирования можно «укоротить» длинный цифровой идентификатор, например чтобы выдать его в качестве URL.

Округление
-----------
В JavaScript существуют целых 3 функции для этого.

Math.floor
----------
Округляет вниз
Math.ceil
----------
Округляет вверх
Math.round
----------
Округляет до ближайшего целого
```
alert( Math.floor(3.1) );  // 3
alert( Math.ceil(3.1) );   // 4
alert( Math.round(3.1) );  // 3
```
Округление битовыми операторами
-------------------------------
Битовые операторы делают любое число 32-битным целым, обрезая десятичную часть.
В результате побитовая операция, которая не изменяет число, например, двойное битовое НЕ — округляет его:
```
alert( ~~12.3 ); // 12
```
Любая побитовая операция такого рода подойдет, например XOR (исключающее ИЛИ, "^") с нулем:
```
alert( 12.3 ^ 0 ); // 12
alert( 1.2 + 1.3 ^ 0 ); // 2, приоритет ^ меньше, чем +
```
Это удобно в первую очередь тем, что легко читается и не заставляет ставить дополнительные скобки как Math.floor(...):
```
var x = a * b / c ^ 0; // читается как "a * b / c и округлить"
```
Округление до заданной точности
-------------------------------
Для округления до нужной цифры после запятой можно умножить и поделить на 10 с нужным количеством нулей. Например, округлим 3.456 до 2го знака после запятой:
```
var n = 3.456;
alert( Math.round(n * 100) / 100 ); // 3.456 -> 345.6 -> 346 -> 3.46
```
Таким образом можно округлять число и вверх и вниз.

num.toFixed(precision)
-----------------------
Существует также специальный метод num.toFixed(precision), который округляет число num до точности precision и возвращает результат в виде строки:
```
var n = 12.34;
alert( n.toFixed(1) ); // "12.3"
```
Округление идёт до ближайшего значения, аналогично Math.round:
```
var n = 12.36;
alert( n.toFixed(1) ); // "12.4"
```
Итоговая строка, при необходимости, дополняется нулями до нужной точности:
```
var n = 12.34;
alert( n.toFixed(5) ); // "12.34000", добавлены нули до 5 знаков после запятой
```
Если нам нужно именно число, то мы можем получить его, применив '+' к результату n.toFixed(..):
```
var n = 12.34;
alert( +n.toFixed(5) ); // 12.34
```
Метод toFixed не эквивалентен Math.round!
------------------------------------------
Например, произведём округление до одного знака после запятой с использованием двух способов: toFixed и Math.round с умножением и делением:
```
var price = 6.35;

alert( price.toFixed(1) ); // 6.3
alert( Math.round(price * 10) / 10 ); // 6.4
```
Как видно, результат разный! Вариант округления через Math.round получился более корректным, так как по общепринятым правилам 5 округляется вверх. А toFixed может округлить его как вверх, так и вниз.

Неточные вычисления
--------------------
Запустите этот пример:
```
alert( 0.1 + 0.2 == 0.3 );
```
Он вывел false. Результат несколько странный, не так ли? 

```
alert( 0.1 + 0.2 ); // 0.30000000000000004
```
Как видите, произошла небольшая вычислительная ошибка, результат сложения 0.1 + 0.2 немного больше, чем 0.3.
```
alert( 0.1 + 0.2 > 0.3 ); // true
```
Всё дело в том, что в стандарте IEEE 754 на число выделяется ровно 8 байт(=64 бита), не больше и не меньше.

Число 0.1 (одна десятая) записывается просто в десятичном формате. Но в двоичной системе счисления это бесконечная дробь, так как единица на десять в двоичной системе так просто не делится. Также бесконечной дробью является 0.2 (=2/10).

Двоичное значение бесконечных дробей хранится только до определенного знака, поэтому возникает неточность. Её даже можно увидеть:
```
alert( 0.1.toFixed(20) ); // 0.10000000000000000555
```
Когда мы складываем 0.1 и 0.2, то две неточности складываются, получаем незначительную, но всё же ошибку в вычислениях.

Конечно, это не означает, что точные вычисления для таких чисел невозможны. Они возможны. И даже необходимы.

Например, есть два способа сложить 0.1 и 0.2:

- Сделать их целыми, сложить, а потом поделить:
```
alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
```
Это работает, т.к. числа 0.1*10 = 1 и 0.2*10 = 2 могут быть точно представлены в двоичной системе.

Сложить, а затем округлить до разумного знака после запятой. Округления до 10-го знака обычно бывает достаточно, чтобы отсечь ошибку вычислений:
```
var result = 0.1 + 0.2;
alert( +result.toFixed(10) ); // 0.3

alert( 9999999999999999 ); // выведет 10000000000000000
```

Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, остальные 11 бит хранят позицию десятичной точки и один бит — знак. Так что если 52 бит не хватает на цифры, то при записи пропадут младшие разряды.

Интерпретатор не выдаст ошибку, но в результате получится «не совсем то число», что мы и видим в примере выше.

Ради справедливости заметим, что в точности то же самое происходит в любом другом языке, где используется формат IEEE 754, включая Java, C, PHP, Ruby, Perl.

Другие математические методы
------------------------------
JavaScript предоставляет базовые тригонометрические и некоторые другие функции для работы с числами.

Тригонометрия
=============
Встроенные функции для тригонометрических вычислений:

Math.acos(x)
------------
Возвращает арккосинус x (в радианах)
Math.asin(x)
------------
Возвращает арксинус x (в радианах)
Math.atan(x)
------------
Возвращает арктангенс x (в радианах)
Math.atan2(y, x)
----------------
Возвращает угол до точки (y, x). Описание функции: Atan2.
Math.sin(x)
------------
Вычисляет синус x (в радианах)
Math.cos(x)
-----------
Вычисляет косинус x (в радианах)
Math.tan(x)
-----------
Возвращает тангенс x (в радианах)

Функции общего назначения
=========================
Разные полезные функции:

Math.sqrt(x)
------------
Возвращает квадратный корень из x.
Math.log(x)
-----------
Возвращает натуральный (по основанию e) логарифм x.
Math.pow(x, exp)
----------------
Возводит число в степень, возвращает xexp, например Math.pow(2,3) = 8. Работает в том числе с дробными и отрицательными степенями, например: Math.pow(4, -1/2) = 0.5.
Math.abs(x)
-------------
Возвращает абсолютное значение числа
Math.exp(x)
-----------
Возвращает ex, где e — основание натуральных логарифмов.
Math.max(a, b, c...)
--------------------
Возвращает наибольший из списка аргументов
Math.min(a, b, c...)
--------------------
Возвращает наименьший из списка аргументов
Math.random()
-------------
Возвращает псевдо-случайное число в интервале [0,1) – то есть между 0(включительно) и 1(не включая). Генератор случайных чисел инициализуется текущим временем.

Форматирование
===============
Для красивого вывода чисел в стандарте ECMA 402 есть метод toLocaleString():
```
var number = 123456789;

alert( number.toLocaleString() ); // 123 456 789
```
Его поддерживают все современные браузеры, кроме IE10- (для которых нужно подключить библиотеку Intl.JS). Он также умеет форматировать валюту и проценты.

Объекты как ассоциативные массивы
=================================
Объекты в JavaScript сочетают в себе два важных функционала.

- Первый — это ассоциативный массив: структура, пригодная для хранения любых данных.

- Второй — языковые возможности для объектно-ориентированного программирования.

Ассоциативные массивы
=====================

Ассоциативный массив — структура данных, в которой можно хранить любые данные в формате ключ-значение.

Кстати, в других языках программирования такую структуру данных также называют «словарь» и «хэш».

Создание объектов
-----------------
Пустой объект может быть создан одним из двух синтаксисов:

1. o = new Object();
2. o = {}; // пустые фигурные скобки

Обычно все пользуются синтаксисом (2), т.к. он короче.

Операции с объектом
--------------------
Объект может содержать в себе любые значения, которые называются свойствами объекта. Доступ к свойствам осуществляется по имени свойства (иногда говорят «по ключу»).

Например, создадим объект person для хранения информации о человеке:
```
var person = {}; // пока пустой
```
Основные операции с объектами — это создание, получение и удаление свойств.

Для обращения к свойствам используется запись «через точку», вида объект.свойство, например:
```
// при присвоении свойства в объекте автоматически создаётся "ящик"
// с именем "name" и в него записывается содержимое 'Вася'
person.name = 'Вася';

person.age = 25; // запишем ещё одно свойство: с именем 'age' и значением 25
```
Значения хранятся «внутри» объекта. Обратим внимание — любые значения, любых типов: число, строка — не важно.

Чтобы прочитать их — также обратимся через точку:
--------------------------------------------------
```
alert( person.name + ': ' + person.age ); // "Вася: 25"
```
Удаление осуществляется оператором delete:
------------------------------------------
```
delete person.age;
```
Проверка существования свойства с определенным ключом.
------------------------------------------------------
Для проверки существования свойства в объекте есть оператор in.

Его синтаксис: "prop" in obj, причем имя свойства — в виде строки, например:
```
if ("name" in person) {
  alert( "Свойство name существует!" );
}
```
Впрочем, чаще используется другой способ — сравнение значения с undefined.

Дело в том, что в JavaScript можно обратиться к любому свойству объекта, даже если его нет. Ошибки не будет.

Но если свойство не существует, то вернется специальное значение undefined:
```
var person = {};

alert( person.lalala ); // undefined, нет свойства с ключом lalala
```
Таким образом мы можем легко проверить существование свойства — получив его и сравнив с undefined:
```
var person = {
  name: "Василий"
};

alert( person.lalala === undefined ); // true, свойства нет
alert( person.name === undefined ); // false, свойство есть.
``` 
Разница между проверками in и === undefined
-------------------------------------------
Есть два средства для проверки наличия свойства в объекте: первое — оператор in, второе — получить его и сравнить с undefined.

Они почти идентичны, но есть одна небольшая разница.

Дело в том, что технически возможно, что свойство есть и равно undefined:
```
var obj = {};
obj.test = undefined; // добавили свойство со значением undefined

// проверим наличие свойств test и заведомо отсутствующего blabla
alert( obj.test === undefined ); // true
alert( obj.blabla === undefined ); // true
```
…При этом, как видно из кода, при простом сравнении наличие такого свойства будет неотличимо от его отсутствия.

Но оператор in гарантирует правильный результат:
```
var obj = {};
obj.test = undefined;

alert( "test" in obj ); // true
alert( "blabla" in obj ); // false
```
Как правило, в коде мы не будем присваивать undefined, чтобы корректно работали обе проверки. А в качестве значения, обозначающего неизвестность и неопределенность, будем использовать null.

Доступ через квадратные скобки
-------------------------------
Существует альтернативный синтаксис работы со свойствами, использующий квадратные скобки объект['свойство']:
```
var person = {};

person['name'] = 'Вася'; // то же что и person.name = 'Вася'
```
Записи person['name'] и person.name идентичны, но квадратные скобки позволяют использовать в качестве имени свойства любую строку:
```
var person = {};

person['любимый стиль музыки'] = 'Джаз'; // то же что и person.name = 'Вася'
```
Такое присвоение было бы невозможно «через точку», так интерпретатор после первого пробела подумает, что свойство закончилось, и далее выдаст ошибку:
```
person.любимый стиль музыки = 'Джаз'; // ??? ошибка
```
В обоих случаях, имя свойства обязано быть строкой. Если использовано значение другого типа — JavaScript приведет его к строке автоматически.

Доступ к свойству через переменную
----------------------------------
Квадратные скобки также позволяют обратиться к свойству, имя которого хранится в переменной:
```
var person = {};
person.age = 25;
var key = 'age';

alert( person[key] ); // выведет person['age']
```
Вообще, если имя свойства хранится в переменной (var key = "age"), то единственный способ к нему обратиться — это квадратные скобки person[key].

Доступ через точку используется, если мы на этапе написания программы уже знаем название свойства. А если оно будет определено по ходу выполнения, например, введено посетителем и записано в переменную, то единственный выбор — квадратные скобки.

Объявление со свойствами
--------------------------
Объект можно заполнить значениями при создании, указав их в фигурных скобках: { ключ1: значение1, ключ2: значение2, ... }.

Такой синтаксис называется литеральным (англ. literal).
--------------------------------------------------------
Следующие два фрагмента кода создают одинаковый объект:
```
var menuSetup = {
  width: 300,
  height: 200,
  title: "Menu"
};

// то же самое, что:

var menuSetup = {};
menuSetup.width = 300;
menuSetup.height = 200;
menuSetup.title = 'Menu';
```
Названия свойств можно перечислять как в кавычках, так и без, если они удовлетворяют ограничениям для имён переменных.

Например:
```
var menuSetup = {
  width: 300,
  'height': 200,
  "мама мыла раму": true
};
```
В качестве значения можно тут же указать и другой объект:
```
var user = {
  name: "Таня",
  age: 25,
  size: {
    top: 90,
    middle: 60,
    bottom: 90
  }
}

alert(user.name) // "Таня"

alert(user.size.top) // 90
```
Здесь значением свойства size является объект {top: 90, middle: 60, bottom: 90 }.

Компактное представление объектов
---------------------------------

Браузер использует специальное «компактное» представление объектов, чтобы сэкономить память в том случае, когда однотипных объектов много.

Например, посмотрим на такой объект:
```
var user = {
  name: "Vasya",
  age: 25
};
```
Здесь содержится информация о свойстве name и его строковом значении, а также о свойстве age и его численном значении. Представим, что таких объектов много.

Получится, что информация об именах свойств name и age дублируется в каждом объекте. Чтобы этого избежать, браузер применяет оптимизацию.

При создании множества объектов одного и того же вида (с одинаковыми полями) интерпретатор выносит описание полей в отдельную структуру. А сам объект остаётся в виде непрерывной области памяти с данными.

Например, есть много объектов с полями name и age:
```
{name: "Вася", age: 25}
{name: "Петя", age: 22}
{name: "Маша", age: 19}
...
```
Для их эффективного хранения будет создана структура, которая описывает данный вид объектов. Выглядеть она будет примерно так: string name, number age. А сами объекты будут представлены в памяти только данными:
```
<структура: string name, number age>
Вася 25
Петя 22
Маша 19
```
При добавлении нового объекта такой структуры достаточно хранить значения полей, но не их имена. Экономия памяти — налицо.

А что происходит, если к объекту добавляется новое свойство? Например, к одному из них добавили свойство isAdmin:
```
user.isAdmin = true;
```
В этом случае браузер смотрит, есть ли уже структура, под которую подходит такой объект. Если нет — она создаётся и объект привязывается к ней.

Эта оптимизация является примером того, что далеко не всё то, что мы пишем, один-в-один переносится в память.

Современные интерпретаторы очень стараются оптимизировать как код, так и структуры данных. Детали применения и реализации этого способа хранения варьируются от браузера к браузеру.

Объекты: перебор свойств
========================
Для перебора всех свойств из объекта используется цикл по свойствам for..in. Эта синтаксическая конструкция отличается от рассмотренного ранее цикла for(;;).
```
for..in
```
Синтаксис:
```
for (key in obj) {
  /* ... делать что-то с obj[key] ... */
}
```
При этом for..in последовательно переберёт свойства объекта obj, имя каждого свойства будет записано в key и вызвано тело цикла.

Объявление переменной в цикле for (var key in obj)
--------------------------------------------------
Вспомогательную переменную key можно объявить прямо в цикле:
```
            for (var key in menu) {
  // ...
}
```
Так иногда пишут для краткости кода. Можно использовать и любое другое название, кроме key, например for(var propName in menu).

Пример итерации по свойствам:
-----------------------------
```
var menu = {
  width: 300,
  height: 200,
  title: "Menu"
};

for (var key in menu) {
  // этот код будет вызван для каждого свойства объекта
  // ..и выведет имя свойства и его значение

  alert( "Ключ: " + key + " значение: " + menu[key] );
}
```

Количество свойств в объекте
----------------------------
Как узнать, сколько свойств хранит объект?

Готового метода для этого нет.

Самый кросс-браузерный способ — это сделать цикл по свойствам и посчитать, вот так:
```
var menu = {
  width: 300,
  height: 200,
  title: "Menu"
};

var counter = 0;

for (var key in menu) {
  counter++;
}

alert( "Всего свойств: " + counter );
```

В каком порядке перебираются свойства?
--------------------------------------
Для примера, рассмотрим объект, который задаёт список опций для выбора страны:
```
var codes = {
  // телефонные коды в формате "код страны": "название"
  "7": "Россия",
  "38": "Украина",
  // ..,
  "1": "США"
};
```

При переборе for(key in codes) ключи key будут перечислены именно в том порядке, в котором заданы
-------------------------------------------------------------------------------------------------

Соглашение говорит, что если имя свойства — нечисловая строка, то такие ключи всегда перебираются в том же порядке, в каком присваивались. Так получилось по историческим причинам и изменить это сложно: поломается много готового кода.

С другой стороны, если имя свойства — число или числовая строка, то все современные браузеры сортируют такие свойства в целях внутренней оптимизации.

К примеру, рассмотрим объект с заведомо нечисловыми свойствами:
```
var user = {
  name: "Вася",
  surname: "Петров"
};
user.age = 25;

// порядок перебора соответствует порядку присвоения свойства
for (var prop in user) {
  alert( prop ); // name, surname, age
}
А теперь — что будет, если перебрать объект с кодами?

var codes = {
  // телефонные коды в формате "код страны": "название"
  "7": "Россия",
  "38": "Украина",
  "1": "США"
};

for (var code in codes) alert( code ); // 1, 7, 38
```
При запуске этого кода в современном браузере мы увидим, что на первое место попал код США!

Нарушение порядка возникло, потому что ключи численные. Интерпретатор JavaScript видит, что строка на самом деле является числом и преобразует ключ в немного другой внутренний формат. Дополнительным эффектом внутренних оптимизаций является сортировка.

А что, если мы хотим, чтобы порядок был именно таким, какой мы задали?
-----------------------------------------------------------------------
Это возможно. Можно применить небольшой хак, который заключается в том, чтобы сделать все ключи нечисловыми, например, добавим в начало дополнительный символ '+':
```
var codes = {
  "+7": "Россия",
  "+38": "Украина",
  "+1": "США"
};

for (var code in codes) {
  var value = codes[code];
  code = +code; // ..если нам нужно именно число, преобразуем: "+7" -> 7

  alert( code + ": " + value ); // 7, 38, 1 во всех браузерах
}
```
